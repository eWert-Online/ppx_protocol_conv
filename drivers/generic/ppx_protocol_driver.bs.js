// Generated by Melange

import * as Char from "melange/lib/es6/char.js";
import * as Lazy from "melange/lib/es6/lazy.js";
import * as Curry from "melange/lib/es6/curry.js";
import * as Printf from "melange/lib/es6/printf.js";
import * as Stdlib from "melange/lib/es6/stdlib.js";
import * as Printexc from "melange/lib/es6/printexc.js";
import * as Caml_array from "melange/lib/es6/caml_array.js";
import * as ListLabels from "melange/lib/es6/listLabels.js";
import * as ArrayLabels from "melange/lib/es6/arrayLabels.js";
import * as Caml_option from "melange/lib/es6/caml_option.js";
import * as StringLabels from "melange/lib/es6/stringLabels.js";
import * as Caml_exceptions from "melange/lib/es6/caml_exceptions.js";
import * as CamlinternalLazy from "melange/lib/es6/camlinternalLazy.js";
import * as Caml_js_exceptions from "melange/lib/es6/caml_js_exceptions.js";
import * as Runtime$Protocol_conv from "../../runtime/runtime.bs.js";

function field_name(name) {
  return name;
}

function variant_name(name) {
  return name;
}

var Default_parameters = {
  field_name: field_name,
  variant_name: variant_name,
  constructors_without_arguments_as_string: true,
  omit_default_values: true,
  eager: true,
  strict: false
};

function mangle(str) {
  var chars = {
    contents: /* [] */0
  };
  StringLabels.iter((function (ch) {
          chars.contents = {
            hd: ch,
            tl: chars.contents
          };
        }), str);
  var chars$1 = ListLabels.rev(chars.contents);
  var inner = function (_param) {
    while(true) {
      var param = _param;
      if (!param) {
        return /* [] */0;
      }
      var c = param.hd;
      if (c !== 95) {
        return {
                hd: c,
                tl: inner(param.tl)
              };
      }
      var match = param.tl;
      if (!match) {
        return /* [] */0;
      }
      var c$1 = match.hd;
      if (c$1 !== 95) {
        return {
                hd: Char.uppercase_ascii(c$1),
                tl: inner(match.tl)
              };
      }
      _param = {
        hd: /* '_' */95,
        tl: match.tl
      };
      continue ;
    };
  };
  var res_arr = ArrayLabels.of_list(inner(chars$1));
  return StringLabels.init(res_arr.length, (function (i) {
                return Caml_array.get(res_arr, i);
              }));
}

function Make(funarg, funarg$1) {
  var Protocol_error = /* @__PURE__ */Caml_exceptions.create("Ppx_protocol_driver-Protocol_conv.Make(Driver)(P).Protocol_error");
  var make_error = function (value, msg) {
    return [
            msg,
            value
          ];
  };
  var error_to_string_hum = function (param) {
    var t = param[1];
    var s = param[0];
    if (t !== undefined) {
      return Curry._2(Printf.sprintf(/* Format */{
                      _0: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ". Got: ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        }
                      },
                      _1: "%s. Got: %s"
                    }), s, Curry._1(funarg.to_string_hum, Caml_option.valFromOption(t)));
    } else {
      return s;
    }
  };
  Printexc.register_printer(function (err) {
        if (err.RE_EXN_ID === Protocol_error) {
          return error_to_string_hum(err._1);
        }
        
      });
  var raise_errorf = function (t, fmt) {
    return Printf.kprintf((function (s) {
                  throw {
                        RE_EXN_ID: Protocol_error,
                        _1: [
                          s,
                          t
                        ],
                        Error: new Error()
                      };
                }), fmt);
  };
  var try_with = function (f, t) {
    var v;
    try {
      v = Curry._1(f, t);
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === Protocol_error) {
        return {
                TAG: /* Error */1,
                _0: e._1
              };
      }
      throw e;
    }
    return {
            TAG: /* Ok */0,
            _0: v
          };
  };
  var wrap = function (t, f, x) {
    try {
      return Curry._1(f, x);
    }
    catch (raw_s){
      var s = Caml_js_exceptions.internalToOCamlException(raw_s);
      if (s.RE_EXN_ID === Runtime$Protocol_conv.Helper.Protocol_error) {
        throw {
              RE_EXN_ID: Protocol_error,
              _1: [
                s._1,
                Caml_option.some(t)
              ],
              Error: new Error()
            };
      }
      throw {
            RE_EXN_ID: Protocol_error,
            _1: [
              Printexc.to_string(s),
              Caml_option.some(t)
            ],
            Error: new Error()
          };
    }
  };
  var to_record = function (spec, constr) {
    var spec$1 = Runtime$Protocol_conv.Helper.map_record_in(funarg$1.field_name, spec);
    var f = Runtime$Protocol_conv.Helper.to_record(funarg$1.strict, spec$1, constr);
    return function (t) {
      return wrap(t, f, wrap(t, funarg.to_alist, t));
    };
  };
  var of_record = function (spec) {
    return Runtime$Protocol_conv.Helper.of_record(funarg$1.omit_default_values, funarg.of_alist)(Runtime$Protocol_conv.Helper.map_record_out(funarg$1.field_name)(spec));
  };
  var to_tuple = function (spec, constr) {
    var partial_arg = Runtime$Protocol_conv.Helper.to_tuple(spec);
    var f = function (param) {
      return partial_arg(constr, param);
    };
    return function (t) {
      return wrap(t, f, wrap(t, funarg.to_list, t));
    };
  };
  var of_tuple = function (spec) {
    return Runtime$Protocol_conv.Helper.of_tuple(funarg.of_list)(spec);
  };
  var to_variant = function (spec) {
    var f = Runtime$Protocol_conv.Helper.to_variant(Runtime$Protocol_conv.Helper.map_constructor_names(funarg$1.variant_name, spec));
    if (funarg$1.constructors_without_arguments_as_string) {
      return function (t) {
        if (Curry._1(funarg.is_string, t)) {
          return wrap(t, Curry._1(f, wrap(t, funarg.to_string, t)), /* [] */0);
        }
        if (!Curry._1(funarg.is_list, t)) {
          return raise_errorf(Caml_option.some(t), /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Expected list or string when deserialising variant",
                        _1: /* End_of_format */0
                      },
                      _1: "Expected list or string when deserialising variant"
                    });
        }
        var match = Curry._1(funarg.to_list, t);
        if (!match) {
          return raise_errorf(Caml_option.some(t), /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Empty list found when deserialising variant",
                        _1: /* End_of_format */0
                      },
                      _1: "Empty list found when deserialising variant"
                    });
        }
        var name = match.hd;
        if (Curry._1(funarg.is_string, name)) {
          return Curry._1(wrap(t, f, Curry._1(funarg.to_string, name)), match.tl);
        } else {
          return raise_errorf(Caml_option.some(t), /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "First element in the list must be the constructor name when name when deserialising variant",
                        _1: /* End_of_format */0
                      },
                      _1: "First element in the list must be the constructor name when name when deserialising variant"
                    });
        }
      };
    } else {
      return function (t) {
        if (!Curry._1(funarg.is_list, t)) {
          return raise_errorf(Caml_option.some(t), /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Expected list when deserialising variant",
                        _1: /* End_of_format */0
                      },
                      _1: "Expected list when deserialising variant"
                    });
        }
        var match = Curry._1(funarg.to_list, t);
        if (!match) {
          return raise_errorf(Caml_option.some(t), /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Empty list found when deserialising variant",
                        _1: /* End_of_format */0
                      },
                      _1: "Empty list found when deserialising variant"
                    });
        }
        var name = match.hd;
        if (Curry._1(funarg.is_string, name)) {
          return wrap(t, Curry._1(f, Curry._1(funarg.to_string, name)), match.tl);
        } else {
          return raise_errorf(Caml_option.some(t), /* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "First element in the list must be the constructor name when name when deserialising variant",
                        _1: /* End_of_format */0
                      },
                      _1: "First element in the list must be the constructor name when name when deserialising variant"
                    });
        }
      };
    }
  };
  var of_variant = function (name) {
    var name$1 = Curry._1(funarg.of_string, Curry._1(funarg$1.variant_name, name));
    return function (ts) {
      if (ts || !funarg$1.constructors_without_arguments_as_string) {
        return Curry._1(funarg.of_list, {
                    hd: name$1,
                    tl: ts
                  });
      } else {
        return name$1;
      }
    };
  };
  var of_variant$1 = function (name, spec) {
    return Runtime$Protocol_conv.Helper.of_variant(of_variant, name, spec);
  };
  var get_option = function (t) {
    if (!Curry._1(funarg.is_alist, t)) {
      return ;
    }
    var match = Curry._1(funarg.to_alist, t);
    if (!match) {
      return ;
    }
    var match$1 = match.hd;
    if (match$1[0] === "__option" && !match.tl) {
      return Caml_option.some(match$1[1]);
    }
    
  };
  var to_option = function (to_value_fun, t) {
    if (Curry._1(funarg.is_null, t)) {
      return ;
    }
    var t$1 = get_option(t);
    var t$2 = t$1 !== undefined ? Caml_option.valFromOption(t$1) : t;
    return Caml_option.some(Curry._1(to_value_fun, t$2));
  };
  var of_option = function (of_value_fun, v) {
    if (v === undefined) {
      return funarg.$$null;
    }
    var t = Curry._1(of_value_fun, Caml_option.valFromOption(v));
    if (Curry._1(funarg.is_null, t) || get_option(t) !== undefined) {
      return Curry._1(funarg.of_alist, {
                  hd: [
                    "__option",
                    t
                  ],
                  tl: /* [] */0
                });
    } else {
      return t;
    }
  };
  var to_ref = function (to_value_fun, t) {
    var v = Curry._1(to_value_fun, t);
    return {
            contents: v
          };
  };
  var of_ref = function (of_value_fun, v) {
    return Curry._1(of_value_fun, v.contents);
  };
  var to_result = function (to_ok, to_err) {
    var ok = /* Cons */{
      _0: to_ok,
      _1: /* Nil */0
    };
    var err = /* Cons */{
      _0: to_err,
      _1: /* Nil */0
    };
    return to_variant({
                hd: /* Variant */{
                  _0: "Ok",
                  _1: ok,
                  _2: (function (v) {
                      return {
                              TAG: /* Ok */0,
                              _0: v
                            };
                    })
                },
                tl: {
                  hd: /* Variant */{
                    _0: "Error",
                    _1: err,
                    _2: (function (v) {
                        return {
                                TAG: /* Error */1,
                                _0: v
                              };
                      })
                  },
                  tl: /* [] */0
                }
              });
  };
  var of_result = function (of_ok, of_err) {
    var of_ok$1 = of_variant$1("Ok", /* Cons */{
          _0: of_ok,
          _1: /* Nil */0
        });
    var of_err$1 = of_variant$1("Error", /* Cons */{
          _0: of_err,
          _1: /* Nil */0
        });
    return function (ok) {
      if (ok.TAG === /* Ok */0) {
        return Curry._1(of_ok$1, ok._0);
      } else {
        return Curry._1(of_err$1, ok._0);
      }
    };
  };
  var to_list = function (to_value_fun, t) {
    return Runtime$Protocol_conv.Helper.list_map(to_value_fun, wrap(t, funarg.to_list, t));
  };
  var of_list = function (of_value_fun, v) {
    return Curry._1(funarg.of_list, Runtime$Protocol_conv.Helper.list_map(of_value_fun, v));
  };
  var to_array = function (to_value_fun, t) {
    return ArrayLabels.of_list(to_list(to_value_fun, t));
  };
  var of_array = function (of_value_fun, v) {
    return of_list(of_value_fun, ArrayLabels.to_list(v));
  };
  var to_lazy_t = function (to_value_fun) {
    if (funarg$1.eager) {
      return function (t) {
        return Lazy.from_val(Curry._1(to_value_fun, t));
      };
    } else {
      return function (t) {
        return Lazy.from_fun(function (param) {
                    return Curry._1(to_value_fun, t);
                  });
      };
    }
  };
  var of_lazy_t = function (of_value_fun, v) {
    return Curry._1(of_value_fun, CamlinternalLazy.force(v));
  };
  var to_char = function (t) {
    try {
      return Curry._1(funarg.to_char, t);
    }
    catch (exn){
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "char expected",
                    _1: /* End_of_format */0
                  },
                  _1: "char expected"
                });
    }
  };
  var to_int = function (t) {
    try {
      return Curry._1(funarg.to_int, t);
    }
    catch (exn){
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "int expected",
                    _1: /* End_of_format */0
                  },
                  _1: "int expected"
                });
    }
  };
  var to_int32 = function (t) {
    try {
      return Curry._1(funarg.to_int32, t);
    }
    catch (exn){
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "int32 expected",
                    _1: /* End_of_format */0
                  },
                  _1: "int32 expected"
                });
    }
  };
  var to_int64 = function (t) {
    try {
      return Curry._1(funarg.to_int64, t);
    }
    catch (exn){
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "int64 expected",
                    _1: /* End_of_format */0
                  },
                  _1: "int64 expected"
                });
    }
  };
  var to_nativeint = function (t) {
    try {
      return Curry._1(funarg.to_nativeint, t);
    }
    catch (exn){
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "nativeint expected",
                    _1: /* End_of_format */0
                  },
                  _1: "nativeint expected"
                });
    }
  };
  var to_string = function (t) {
    try {
      return Curry._1(funarg.to_string, t);
    }
    catch (exn){
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "string expected",
                    _1: /* End_of_format */0
                  },
                  _1: "string expected"
                });
    }
  };
  var to_float = function (t) {
    try {
      return Curry._1(funarg.to_float, t);
    }
    catch (exn){
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "float expected",
                    _1: /* End_of_format */0
                  },
                  _1: "float expected"
                });
    }
  };
  var to_bool = function (t) {
    try {
      return Curry._1(funarg.to_bool, t);
    }
    catch (exn){
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "bool expected",
                    _1: /* End_of_format */0
                  },
                  _1: "bool expected"
                });
    }
  };
  var to_bytes = function (t) {
    try {
      return Curry._1(funarg.to_bytes, t);
    }
    catch (exn){
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "bytes expected",
                    _1: /* End_of_format */0
                  },
                  _1: "bytes expected"
                });
    }
  };
  var to_unit = function (t) {
    var param = to_option((function (param) {
            
          }), t);
    if (param !== undefined) {
      return raise_errorf(Caml_option.some(t), /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Unit expected",
                    _1: /* End_of_format */0
                  },
                  _1: "Unit expected"
                });
    }
    
  };
  var of_unit = function (param) {
    return of_option((function (param) {
                  return Stdlib.failwith("Should call with None");
                }), undefined);
  };
  return {
          Protocol_error: Protocol_error,
          make_error: make_error,
          error_to_string_hum: error_to_string_hum,
          to_string_hum: funarg.to_string_hum,
          try_with: try_with,
          to_variant: to_variant,
          of_variant: of_variant$1,
          to_record: to_record,
          of_record: of_record,
          to_tuple: to_tuple,
          of_tuple: of_tuple,
          to_option: to_option,
          of_option: of_option,
          to_ref: to_ref,
          of_ref: of_ref,
          to_list: to_list,
          of_list: of_list,
          to_array: to_array,
          of_array: of_array,
          to_lazy_t: to_lazy_t,
          of_lazy_t: of_lazy_t,
          to_result: to_result,
          of_result: of_result,
          to_int: to_int,
          of_int: funarg.of_int,
          to_int32: to_int32,
          of_int32: funarg.of_int32,
          to_int64: to_int64,
          of_int64: funarg.of_int64,
          to_nativeint: to_nativeint,
          of_nativeint: funarg.of_nativeint,
          to_char: to_char,
          of_char: funarg.of_char,
          to_string: to_string,
          of_string: funarg.of_string,
          to_float: to_float,
          of_float: funarg.of_float,
          to_bool: to_bool,
          of_bool: funarg.of_bool,
          to_bytes: to_bytes,
          of_bytes: funarg.of_bytes,
          to_unit: to_unit,
          of_unit: of_unit
        };
}

export {
  Default_parameters ,
  mangle ,
  Make ,
}
/* Printexc Not a pure module */
