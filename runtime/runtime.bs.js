// Generated by Melange

import * as Curry from "melange/lib/es6/curry.js";
import * as Printf from "melange/lib/es6/printf.js";
import * as Stdlib from "melange/lib/es6/stdlib.js";
import * as Hashtbl from "melange/lib/es6/hashtbl.js";
import * as Caml_obj from "melange/lib/es6/caml_obj.js";
import * as Caml_array from "melange/lib/es6/caml_array.js";
import * as ListLabels from "melange/lib/es6/listLabels.js";
import * as Caml_option from "melange/lib/es6/caml_option.js";
import * as Caml_exceptions from "melange/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "melange/lib/es6/caml_js_exceptions.js";

function $caret$colon$colon(a, b) {
  return /* Cons */{
          _0: a,
          _1: b
        };
}

var Record_in = {
  $caret$colon$colon: $caret$colon$colon
};

function $caret$colon$colon$1(a, b) {
  return /* Cons */{
          _0: a,
          _1: b
        };
}

var Record_out = {
  $caret$colon$colon: $caret$colon$colon$1
};

function $caret$colon$colon$2(a, b) {
  return /* Cons */{
          _0: a,
          _1: b
        };
}

var Tuple_in = {
  $caret$colon$colon: $caret$colon$colon$2
};

function $caret$colon$colon$3(a, b) {
  return /* Cons */{
          _0: a,
          _1: b
        };
}

var Tuple_out = {
  $caret$colon$colon: $caret$colon$colon$3
};

var Variant_in = {};

function list_map(f, l) {
  var count_map = function (f, l, ctr) {
    if (!l) {
      return /* [] */0;
    }
    var match = l.tl;
    var x1 = l.hd;
    if (match) {
      var match$1 = match.tl;
      var x2 = match.hd;
      if (match$1) {
        var match$2 = match$1.tl;
        var x3 = match$1.hd;
        if (match$2) {
          var match$3 = match$2.tl;
          var x4 = match$2.hd;
          if (match$3) {
            var tl = match$3.tl;
            var f1 = Curry._1(f, x1);
            var f2 = Curry._1(f, x2);
            var f3 = Curry._1(f, x3);
            var f4 = Curry._1(f, x4);
            var f5 = Curry._1(f, match$3.hd);
            return {
                    hd: f1,
                    tl: {
                      hd: f2,
                      tl: {
                        hd: f3,
                        tl: {
                          hd: f4,
                          tl: {
                            hd: f5,
                            tl: ctr > 1000 ? ListLabels.rev(ListLabels.rev_map(f, tl)) : count_map(f, tl, ctr + 1 | 0)
                          }
                        }
                      }
                    }
                  };
          }
          var f1$1 = Curry._1(f, x1);
          var f2$1 = Curry._1(f, x2);
          var f3$1 = Curry._1(f, x3);
          var f4$1 = Curry._1(f, x4);
          return {
                  hd: f1$1,
                  tl: {
                    hd: f2$1,
                    tl: {
                      hd: f3$1,
                      tl: {
                        hd: f4$1,
                        tl: /* [] */0
                      }
                    }
                  }
                };
        }
        var f1$2 = Curry._1(f, x1);
        var f2$2 = Curry._1(f, x2);
        var f3$2 = Curry._1(f, x3);
        return {
                hd: f1$2,
                tl: {
                  hd: f2$2,
                  tl: {
                    hd: f3$2,
                    tl: /* [] */0
                  }
                }
              };
      }
      var f1$3 = Curry._1(f, x1);
      var f2$3 = Curry._1(f, x2);
      return {
              hd: f1$3,
              tl: {
                hd: f2$3,
                tl: /* [] */0
              }
            };
    }
    var f1$4 = Curry._1(f, x1);
    return {
            hd: f1$4,
            tl: /* [] */0
          };
  };
  return count_map(f, l, 0);
}

var l = {
  hd: 1,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: {
        hd: 4,
        tl: {
          hd: 5,
          tl: /* [] */0
        }
      }
    }
  }
};

var l$p = list_map((function (x) {
        return x + 2 | 0;
      }), l);

var l$p$p = ListLabels.map((function (x) {
        return x + 2 | 0;
      }), l);

if (!Caml_obj.caml_equal(l$p, l$p$p)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "runtime.ml",
          164,
          4
        ],
        Error: new Error()
      };
}

var Protocol_error = /* @__PURE__ */Caml_exceptions.create("Runtime-Protocol_conv.Helper.Protocol_error");

function of_alist(alist) {
  var tbl = Hashtbl.create(undefined, 0);
  ListLabels.iter((function (param) {
          Hashtbl.add(tbl, param[0], param[1]);
        }), alist);
  return function (k) {
    var k$1;
    try {
      k$1 = Hashtbl.find(tbl, k);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        return ;
      }
      throw exn;
    }
    return Caml_option.some(k$1);
  };
}

var Hashtbl_lookup = {
  of_alist: of_alist
};

function raise_errorf(fmt) {
  return Printf.ksprintf((function (s) {
                throw {
                      RE_EXN_ID: Protocol_error,
                      _1: s,
                      Error: new Error()
                    };
              }), fmt);
}

function map_record_in(field, param) {
  if (!param) {
    return /* Nil */0;
  }
  var match = param._0;
  return /* Cons */{
          _0: [
            Curry._1(field, match[0]),
            match[1],
            match[2]
          ],
          _1: map_record_in(field, param._1)
        };
}

function to_alist(idx, param) {
  if (param) {
    return {
            hd: [
              param._0[0],
              idx
            ],
            tl: to_alist(idx + 1 | 0, param._1)
          };
  } else {
    return /* [] */0;
  }
}

function inner(idx) {
  var value_of = function (to_v, field, $$default, t) {
    if (t !== undefined) {
      return Curry._1(to_v, Caml_option.valFromOption(t));
    } else if ($$default !== undefined) {
      return Caml_option.valFromOption($$default);
    } else {
      return Curry._1(raise_errorf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Missing record field: ",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: /* End_of_format */0
                        }
                      },
                      _1: "Missing record field: %s"
                    }), field);
    }
  };
  return function (param) {
    if (!param) {
      return function (a, _values) {
        return a;
      };
    }
    var match = param._0;
    var d1 = match[2];
    var f1 = match[1];
    var n1 = match[0];
    var cont = inner(idx + 1 | 0)(param._1);
    return function (constr, values) {
      var v1 = value_of(f1, n1, d1, Caml_array.get(values, idx + 0 | 0));
      return Curry._2(cont, Curry._1(constr, v1), values);
    };
  };
}

function to_record(strictOpt, spec, constr) {
  var strict = strictOpt !== undefined ? strictOpt : false;
  var alist = to_alist(0, spec);
  var lookup = of_alist(alist);
  var count = ListLabels.length(alist);
  var f = Curry._1(inner(0)(spec), constr);
  return function (values) {
    var value_array = Caml_array.make(count, undefined);
    ListLabels.iter((function (param) {
            var field = param[0];
            var idx = Curry._1(lookup, field);
            if (idx === undefined) {
              if (strict) {
                return Curry._1(raise_errorf(/* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "Unused field when deserialising record: ",
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: /* End_of_format */0
                                  }
                                },
                                _1: "Unused field when deserialising record: %s"
                              }), field);
              } else {
                return ;
              }
            }
            var match = Caml_array.get(value_array, idx);
            if (match !== undefined) {
              return Curry._1(raise_errorf(/* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "Multiple fields with the same name: ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: /* End_of_format */0
                                }
                              },
                              _1: "Multiple fields with the same name: %s"
                            }), field);
            } else {
              return Caml_array.set(value_array, idx, Caml_option.some(param[1]));
            }
          }), values);
    return Curry._1(f, value_array);
  };
}

function map_record_out(field) {
  return function (param) {
    if (!param) {
      return /* Nil */0;
    }
    var match = param._0;
    return /* Cons */{
            _0: [
              Curry._1(field, match[0]),
              match[1],
              match[2]
            ],
            _1: map_record_out(field)(param._1)
          };
  };
}

function of_record(omit_default, serialize_record) {
  var inner = function (param) {
    if (!param) {
      return Curry.__1(serialize_record);
    }
    var match = param._0;
    var n1 = match[0];
    var d1 = match[2];
    if (d1 !== undefined && omit_default) {
      var d1$1 = Caml_option.valFromOption(d1);
      var f1 = match[1];
      var cont = inner(param._1);
      return function (acc, v1) {
        if (Caml_obj.caml_equal(d1$1, v1)) {
          return Curry._1(cont, acc);
        } else {
          return Curry._1(cont, {
                      hd: [
                        n1,
                        Curry._1(f1, v1)
                      ],
                      tl: acc
                    });
        }
      };
    }
    var f1$1 = match[1];
    var cont$1 = inner(param._1);
    return function (acc, v1) {
      return Curry._1(cont$1, {
                  hd: [
                    n1,
                    Curry._1(f1$1, v1)
                  ],
                  tl: acc
                });
    };
  };
  return function (spec) {
    return Curry._1(inner(spec), /* [] */0);
  };
}

function to_tuple(param) {
  if (!param) {
    return function (a, param) {
      if (param) {
        return raise_errorf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Too many elements when parsing tuple",
                      _1: /* End_of_format */0
                    },
                    _1: "Too many elements when parsing tuple"
                  });
      } else {
        return a;
      }
    };
  }
  var f1 = param._0;
  var cont = to_tuple(param._1);
  return function (constructor, param) {
    if (param) {
      return Curry._2(cont, Curry._1(constructor, Curry._1(f1, param.hd)), param.tl);
    } else {
      return raise_errorf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Too few elements when parsing tuple",
                    _1: /* End_of_format */0
                  },
                  _1: "Too few elements when parsing tuple"
                });
    }
  };
}

function of_tuple(serialize_tuple) {
  var inner = function (param) {
    if (!param) {
      return function (acc) {
        return Curry._1(serialize_tuple, ListLabels.rev(acc));
      };
    }
    var match = param._1;
    var f1 = param._0;
    if (!match) {
      return function (acc, v1) {
        return Curry._1(serialize_tuple, ListLabels.rev_append(acc, {
                        hd: Curry._1(f1, v1),
                        tl: /* [] */0
                      }));
      };
    }
    var match$1 = match._1;
    var f2 = match._0;
    if (!match$1) {
      return function (acc, v1, v2) {
        return Curry._1(serialize_tuple, ListLabels.rev_append(acc, {
                        hd: Curry._1(f1, v1),
                        tl: {
                          hd: Curry._1(f2, v2),
                          tl: /* [] */0
                        }
                      }));
      };
    }
    var match$2 = match$1._1;
    var f3 = match$1._0;
    if (!match$2) {
      return function (acc, v1, v2, v3) {
        return Curry._1(serialize_tuple, ListLabels.rev_append(acc, {
                        hd: Curry._1(f1, v1),
                        tl: {
                          hd: Curry._1(f2, v2),
                          tl: {
                            hd: Curry._1(f3, v3),
                            tl: /* [] */0
                          }
                        }
                      }));
      };
    }
    var match$3 = match$2._1;
    var f4 = match$2._0;
    if (!match$3) {
      return function (acc, v1, v2, v3, v4) {
        return Curry._1(serialize_tuple, ListLabels.rev_append(acc, {
                        hd: Curry._1(f1, v1),
                        tl: {
                          hd: Curry._1(f2, v2),
                          tl: {
                            hd: Curry._1(f3, v3),
                            tl: {
                              hd: Curry._1(f4, v4),
                              tl: /* [] */0
                            }
                          }
                        }
                      }));
      };
    }
    var f5 = match$3._0;
    var cont = inner(match$3._1);
    return function (acc, v1, v2, v3, v4, v5) {
      return Curry._1(cont, {
                  hd: Curry._1(f5, v5),
                  tl: {
                    hd: Curry._1(f4, v4),
                    tl: {
                      hd: Curry._1(f3, v3),
                      tl: {
                        hd: Curry._1(f2, v2),
                        tl: {
                          hd: Curry._1(f1, v1),
                          tl: acc
                        }
                      }
                    }
                  }
                });
    };
  };
  return function (spec) {
    return Curry._1(inner(spec), /* [] */0);
  };
}

function of_variant(serialize_variant, name, spec) {
  return of_tuple(Curry._1(serialize_variant, name))(spec);
}

function map_constructor_names(constructor, variant) {
  return ListLabels.map((function (param) {
                return /* Variant */{
                        _0: Curry._1(constructor, param._0),
                        _1: param._1,
                        _2: param._2
                      };
              }), variant);
}

function to_variant(spec) {
  var lookup = of_alist(ListLabels.map((function (param) {
              var constr = param._2;
              var partial_arg = to_tuple(param._1);
              return [
                      param._0,
                      (function (param) {
                          return partial_arg(constr, param);
                        })
                    ];
            }), spec));
  return function (name, args) {
    var f = Curry._1(lookup, name);
    if (f !== undefined) {
      return Curry._1(f, args);
    } else {
      return Curry._1(raise_errorf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Unknown variant name: ",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: /* End_of_format */0
                        }
                      },
                      _1: "Unknown variant name: %s"
                    }), name);
    }
  };
}

var Helper = {
  list_map: list_map,
  Protocol_error: Protocol_error,
  Hashtbl_lookup: Hashtbl_lookup,
  raise_errorf: raise_errorf,
  map_record_in: map_record_in,
  to_record: to_record,
  map_record_out: map_record_out,
  of_record: of_record,
  to_tuple: to_tuple,
  of_tuple: of_tuple,
  of_variant: of_variant,
  map_constructor_names: map_constructor_names,
  to_variant: to_variant
};

export {
  Record_in ,
  Record_out ,
  Tuple_in ,
  Tuple_out ,
  Variant_in ,
  Helper ,
}
/* l' Not a pure module */
